{"ast":null,"code":"import { useRef, useEffect } from 'react';\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nfunction getRandomChar(range) {\n  var rand = 0;\n  if (range.length === 2) {\n    rand = getRandomInt(range[0], range[1]);\n  } else {\n    rand = range[getRandomInt(0, range.length - 1)];\n  }\n  return String.fromCharCode(rand);\n}\nvar useScramble = function useScramble(props) {\n  var _props$playOnMount = props.playOnMount,\n    playOnMount = _props$playOnMount === void 0 ? true : _props$playOnMount,\n    _props$text = props.text,\n    text = _props$text === void 0 ? '' : _props$text,\n    _props$speed = props.speed,\n    speed = _props$speed === void 0 ? 1 : _props$speed,\n    _props$seed = props.seed,\n    seed = _props$seed === void 0 ? 1 : _props$seed,\n    _props$step = props.step,\n    step = _props$step === void 0 ? 1 : _props$step,\n    _props$tick = props.tick,\n    tick = _props$tick === void 0 ? 1 : _props$tick,\n    _props$scramble = props.scramble,\n    scramble = _props$scramble === void 0 ? 1 : _props$scramble,\n    _props$chance = props.chance,\n    chance = _props$chance === void 0 ? 1 : _props$chance,\n    _props$overflow = props.overflow,\n    overflow = _props$overflow === void 0 ? true : _props$overflow,\n    _props$range = props.range,\n    range = _props$range === void 0 ? [65, 125] : _props$range,\n    _props$overdrive = props.overdrive,\n    overdrive = _props$overdrive === void 0 ? true : _props$overdrive,\n    onAnimationStart = props.onAnimationStart,\n    onAnimationFrame = props.onAnimationFrame,\n    onAnimationEnd = props.onAnimationEnd,\n    _props$ignore = props.ignore,\n    ignore = _props$ignore === void 0 ? [' '] : _props$ignore;\n  var prefersReducedMotion = typeof window !== \"undefined\" ? window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches : false;\n  if (prefersReducedMotion) {\n    step = text.length;\n    chance = 0;\n    overdrive = false;\n  }\n  // text node ref\n  var nodeRef = useRef(null);\n  // animation frame request\n  var rafRef = useRef(0);\n  // compute\n  var elapsedRef = useRef(0);\n  var fpsInterval = 1000 / (60 * speed);\n  // scramble step\n  var stepRef = useRef(0);\n  // current character index ref\n  var scrambleIndexRef = useRef(0);\n  // scramble controller\n  var controlRef = useRef([]);\n  // overdrive control index\n  var overdriveRef = useRef(0);\n  var setIfNotIgnored = function setIfNotIgnored(value, replace) {\n    return ignore.includes(\"\" + value) ? value : replace;\n  };\n  // pick random character ahead in the string, and add them to the randomizer\n  var seedForward = function seedForward() {\n    if (scrambleIndexRef.current === text.length) return;\n    for (var i = 0; i < seed; i++) {\n      var index = getRandomInt(scrambleIndexRef.current, controlRef.current.length);\n      if (typeof controlRef.current[index] !== 'number' && typeof controlRef.current[index] !== 'undefined') {\n        controlRef.current[index] = setIfNotIgnored(controlRef.current[index], getRandomInt(0, 10) >= (1 - chance) * 10 ? scramble || seed : 0);\n      }\n    }\n  };\n  // add `step` characters to the randomizer, and increase the scrambleIndexRef pointer\n  var stepForward = function stepForward() {\n    for (var i = 0; i < step; i++) {\n      if (scrambleIndexRef.current < text.length) {\n        var currentIndex = scrambleIndexRef.current;\n        var shouldScramble = getRandomInt(0, 10) >= (1 - chance) * 10;\n        controlRef.current[currentIndex] = setIfNotIgnored(text[scrambleIndexRef.current], shouldScramble ? scramble + getRandomInt(0, Math.ceil(scramble / 2)) : 0);\n        scrambleIndexRef.current++;\n      }\n    }\n  };\n  var resizeControl = function resizeControl() {\n    if (text.length < controlRef.current.length) {\n      controlRef.current.pop();\n      controlRef.current.splice(text.length, step);\n    }\n    for (var i = 0; i < step; i++) {\n      if (controlRef.current.length < text.length) {\n        controlRef.current.push(setIfNotIgnored(text[controlRef.current.length + 1], null));\n      }\n    }\n  };\n  var onOverdrive = function onOverdrive() {\n    if (!overdrive) return;\n    for (var i = 0; i < step; i++) {\n      var max = Math.max(controlRef.current.length, text.length);\n      if (overdriveRef.current < max) {\n        controlRef.current[overdriveRef.current] = setIfNotIgnored(text[overdriveRef.current], String.fromCharCode(typeof overdrive === 'boolean' ? 95 : overdrive));\n        overdriveRef.current++;\n      }\n    }\n  };\n  var onTick = function onTick() {\n    stepForward();\n    resizeControl();\n    seedForward();\n  };\n  /**\r\n   * Control the animation framerate, from the speed prop\r\n   *\r\n   * if speed is 0, stop the animation\r\n   */\n  var animate = function animate(time) {\n    if (!speed) return;\n    rafRef.current = requestAnimationFrame(animate);\n    onOverdrive();\n    var timeElapsed = time - elapsedRef.current;\n    if (timeElapsed > fpsInterval) {\n      elapsedRef.current = time;\n      if (stepRef.current % tick === 0) {\n        onTick();\n      }\n      draw();\n    }\n  };\n  /**\r\n   * Redraw text on every animation frame\r\n   */\n  var draw = function draw() {\n    if (!nodeRef.current) return;\n    var result = '';\n    for (var i = 0; i < controlRef.current.length; i++) {\n      var controlValue = controlRef.current[i];\n      switch (true) {\n        /**\r\n         * a positive integer value, get a random character\r\n         */\n        case typeof controlValue === 'number' && controlValue > 0:\n          result += getRandomChar(range);\n          if (i <= scrambleIndexRef.current) {\n            // reduce scramble index only if it's past the scrambleIndexRef\n            controlRef.current[i] = controlRef.current[i] - 1;\n          }\n          break;\n        /**\r\n         * a string from the previous text\r\n         */\n        case typeof controlValue === 'string' && (i >= text.length || i >= scrambleIndexRef.current):\n          result += controlValue;\n          break;\n        /**\r\n         * before scramble index, and equal to the string\r\n         */\n        case controlValue === text[i] && i < scrambleIndexRef.current:\n          result += text[i];\n          break;\n        /**\r\n         * scramble has finished\r\n         */\n        case controlValue === 0 && i < text.length:\n          result += text[i];\n          controlRef.current[i] = text[i];\n          break;\n        default:\n          result += '';\n      }\n    }\n    // set text\n    nodeRef.current.innerHTML = result;\n    onAnimationFrame && onAnimationFrame(result);\n    /**\r\n     * Exit if the result is equal to the input\r\n     *\r\n     * - Trim control to text length\r\n     * - fire onAnimationEnd\r\n     */\n    if (result === text) {\n      controlRef.current.splice(text.length, controlRef.current.length);\n      onAnimationEnd && onAnimationEnd();\n      cancelAnimationFrame(rafRef.current);\n    }\n    stepRef.current++;\n  };\n  /**\r\n   * Reset scramble controls\r\n   *\r\n   * if overflow is true, overflow the control to the an empty array, the size of the text input. This will cause the animation to play from an empty string\r\n   */\n  var reset = function reset() {\n    stepRef.current = 0;\n    scrambleIndexRef.current = 0;\n    overdriveRef.current = 0;\n    if (!overflow) {\n      controlRef.current = new Array(text == null ? void 0 : text.length);\n    }\n  };\n  /**\r\n   * Restarts the animation\r\n   *\r\n   * Cancels the current animation frame, resets the scramble index and other controls, and requests a new animation\r\n   */\n  var play = function play() {\n    cancelAnimationFrame(rafRef.current);\n    reset();\n    onAnimationStart && onAnimationStart();\n    rafRef.current = requestAnimationFrame(animate);\n  };\n  /**\r\n   * reset scramble when text input is changed\r\n   */\n  useEffect(function () {\n    reset();\n  }, [text]);\n  /**\r\n   * start or stop animation when text and speed change\r\n   */\n  useEffect(function () {\n    cancelAnimationFrame(rafRef.current);\n    rafRef.current = requestAnimationFrame(animate);\n    // cancel raf on unmount\n    return function () {\n      cancelAnimationFrame(rafRef.current);\n    };\n  }, [animate]);\n  useEffect(function () {\n    if (!playOnMount) {\n      controlRef.current = text.split('');\n      stepRef.current = text.length;\n      scrambleIndexRef.current = text.length;\n      overdriveRef.current = text.length;\n      draw();\n      cancelAnimationFrame(rafRef.current);\n    }\n  }, []);\n  return {\n    ref: nodeRef,\n    replay: play\n  };\n};\nexport { useScramble };","map":{"version":3,"names":["getRandomInt","min","max","Math","floor","random","getRandomChar","range","rand","length","String","fromCharCode","useScramble","props","_props$playOnMount","playOnMount","_props$text","text","_props$speed","speed","_props$seed","seed","_props$step","step","_props$tick","tick","_props$scramble","scramble","_props$chance","chance","_props$overflow","overflow","_props$range","_props$overdrive","overdrive","onAnimationStart","onAnimationFrame","onAnimationEnd","_props$ignore","ignore","prefersReducedMotion","window","matchMedia","matches","nodeRef","useRef","rafRef","elapsedRef","fpsInterval","stepRef","scrambleIndexRef","controlRef","overdriveRef","setIfNotIgnored","value","replace","includes","seedForward","current","i","index","stepForward","currentIndex","shouldScramble","ceil","resizeControl","pop","splice","push","onOverdrive","onTick","animate","time","requestAnimationFrame","timeElapsed","draw","result","controlValue","innerHTML","cancelAnimationFrame","reset","Array","play","useEffect","split","ref","replay"],"sources":["/Users/jeanmarquesvieira/Desktop/react-projs/jmv/node_modules/use-scramble/src/index.ts"],"sourcesContent":["import { useEffect, useRef } from 'react';\n\nfunction getRandomInt(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction getRandomChar(range: RangeOrCharCodes) {\n  let rand = 0;\n  if (range.length === 2) {\n    rand = getRandomInt(range[0], range[1]);\n  } else {\n    rand = range[getRandomInt(0, range.length - 1)];\n  }\n\n  return String.fromCharCode(rand);\n}\n\ntype RangeOrCharCodes = {\n  0: number;\n  1: number;\n} & Array<number>;\n\nexport type UseScrambleProps = {\n  /**\n   * When playOnMount is true, the animation will not play the first time a text input is provided.\n   */\n  playOnMount?: boolean;\n  /**\n   * Optional text input\n   */\n  text?: string;\n  /**\n   * 0-1 range that determines the scramble speed. A speed of 1 will redraw 60 times a second. A speed of 0 will pause the animation\n   *\n   * @default 1\n   */\n  speed?: number;\n  /**\n   * The controller will move forward along the text input and scramble more characters, at a pace of `tick` frames. Combined with the `speed` prop, you can control the animation rate\n   *\n   * @default 1\n   */\n  tick?: number;\n  /**\n   * Step forward on every tick\n   *\n   * @default 1\n   */\n  step?: number;\n\n  /**\n   * Chance of scrambling a character, range from 0 to 1, 0 being no chance, and 1 being 100% chance\n   */\n  chance?: number;\n  /**\n   * Randomize `seed` characters at random text positions\n   *\n   * @default 1\n   */\n  seed?: number;\n  /**\n   * How many times to scramble each character?\n   *\n   * @default 1\n   */\n  scramble?: number;\n  /**\n   * Characters to avoid scrambling\n   */\n  ignore?: string[];\n\n  /**\n   * Unicode character range for scrambler.\n   *\n   * If a tupple is provided [60,125], it will randomly choose a unicode character code within that range.\n   *\n   * If the array contains more than two unicode values, it will choose randomly from the array values only.\n   *\n   * To randomize with only two values, you can repeat them in the array [91,93,91,93]\n   *\n   * @default [65,125]\n   */\n  range?: RangeOrCharCodes;\n  /**\n   * Set the animation to overdrive mode, and set the unicode character code to use in the animation\n   */\n  overdrive?: boolean | number;\n  /**\n   * Always start text animation from an empty string\n   *\n   * @default false\n   */\n  overflow?: boolean;\n\n  /**\n   * Callback when animation starts drawing\n   */\n  onAnimationStart?: Function;\n\n  /**\n   * Callback for when the animation finished\n   */\n  onAnimationEnd?: Function;\n\n  /**\n   * onRedraw callback\n   */\n  onAnimationFrame?: (result: string) => void;\n};\n\nexport const useScramble = (props: UseScrambleProps) => {\n  let {\n    playOnMount = true,\n    text = '',\n    speed = 1,\n    seed = 1,\n    step = 1,\n    tick = 1,\n    scramble = 1,\n    chance = 1,\n    overflow = true,\n    range = [65, 125],\n    overdrive = true,\n    onAnimationStart,\n    onAnimationFrame,\n    onAnimationEnd,\n    ignore = [' '],\n  } = props;\n\n  const prefersReducedMotion =\n    typeof window !== \"undefined\"\n      ? window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\n      : false;\n\n  if (prefersReducedMotion) {\n    step = text.length;\n    chance = 0;\n    overdrive = false;\n  }\n\n  // text node ref\n  const nodeRef = useRef<any>(null);\n\n  // animation frame request\n  const rafRef = useRef<number>(0);\n\n  // compute\n  const elapsedRef = useRef(0);\n  const fpsInterval = 1000 / (60 * speed);\n\n  // scramble step\n  const stepRef = useRef<number>(0);\n\n  // current character index ref\n  const scrambleIndexRef = useRef<number>(0);\n\n  // scramble controller\n  const controlRef = useRef<Array<string | number | null>>([]);\n\n  // overdrive control index\n  const overdriveRef = useRef<number>(0);\n\n  const setIfNotIgnored = (\n    value: string | number | null | number,\n    replace: string | number | null\n  ) => (ignore.includes(`${value}`) ? value : replace);\n\n  // pick random character ahead in the string, and add them to the randomizer\n  const seedForward = () => {\n    if (scrambleIndexRef.current === text.length) return;\n\n    for (var i = 0; i < seed; i++) {\n      const index = getRandomInt(\n        scrambleIndexRef.current,\n        controlRef.current.length\n      );\n      if (\n        typeof controlRef.current[index] !== 'number' &&\n        typeof controlRef.current[index] !== 'undefined'\n      ) {\n        controlRef.current[index] = setIfNotIgnored(\n          controlRef.current[index],\n          getRandomInt(0, 10) >= (1 - chance) * 10 ? scramble || seed : 0\n        );\n      }\n    }\n  };\n\n  // add `step` characters to the randomizer, and increase the scrambleIndexRef pointer\n  const stepForward = () => {\n    for (var i = 0; i < step; i++) {\n      if (scrambleIndexRef.current < text.length) {\n        const currentIndex = scrambleIndexRef.current;\n\n        const shouldScramble = getRandomInt(0, 10) >= (1 - chance) * 10;\n\n        controlRef.current[currentIndex] = setIfNotIgnored(\n          text[scrambleIndexRef.current],\n          shouldScramble\n            ? scramble + getRandomInt(0, Math.ceil(scramble / 2))\n            : 0\n        );\n        scrambleIndexRef.current++;\n      }\n    }\n  };\n\n  const resizeControl = () => {\n    if (text.length < controlRef.current.length) {\n      controlRef.current.pop();\n      controlRef.current.splice(text.length, step);\n    }\n    for (var i = 0; i < step; i++) {\n      if (controlRef.current.length < text.length) {\n        controlRef.current.push(\n          setIfNotIgnored(text[controlRef.current.length + 1], null)\n        );\n      }\n    }\n  };\n\n  const onOverdrive = () => {\n    if (!overdrive) return;\n\n    for (var i = 0; i < step; i++) {\n      const max = Math.max(controlRef.current.length, text.length);\n      if (overdriveRef.current < max) {\n        controlRef.current[overdriveRef.current] = setIfNotIgnored(\n          text[overdriveRef.current],\n          String.fromCharCode(typeof overdrive === 'boolean' ? 95 : overdrive)\n        );\n        overdriveRef.current++;\n      }\n    }\n  };\n\n  const onTick = () => {\n    stepForward();\n    resizeControl();\n    seedForward();\n  };\n\n  /**\n   * Control the animation framerate, from the speed prop\n   *\n   * if speed is 0, stop the animation\n   */\n  const animate = (time: number) => {\n    if (!speed) return;\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    onOverdrive();\n\n    const timeElapsed = time - elapsedRef.current;\n    if (timeElapsed > fpsInterval) {\n      elapsedRef.current = time;\n\n      if (stepRef.current % tick === 0) {\n        onTick();\n      }\n\n      draw();\n    }\n  };\n\n  /**\n   * Redraw text on every animation frame\n   */\n  const draw = () => {\n    if (!nodeRef.current) return;\n\n    let result = '';\n\n    for (var i = 0; i < controlRef.current.length; i++) {\n      const controlValue = controlRef.current[i];\n\n      switch (true) {\n        /**\n         * a positive integer value, get a random character\n         */\n        case typeof controlValue === 'number' && controlValue > 0:\n          result += getRandomChar(range);\n\n          if (i <= scrambleIndexRef.current) {\n            // reduce scramble index only if it's past the scrambleIndexRef\n            controlRef.current[i] = (controlRef.current[i] as number) - 1;\n          }\n          break;\n\n        /**\n         * a string from the previous text\n         */\n        case typeof controlValue === 'string' &&\n          (i >= text.length || i >= scrambleIndexRef.current):\n          result += controlValue;\n          break;\n\n        /**\n         * before scramble index, and equal to the string\n         */\n        case controlValue === text[i] && i < scrambleIndexRef.current:\n          result += text[i];\n          break;\n\n        /**\n         * scramble has finished\n         */\n        case controlValue === 0 && i < text.length:\n          result += text[i];\n          controlRef.current[i] = text[i];\n          break;\n\n        default:\n          result += '';\n      }\n    }\n\n    // set text\n    nodeRef.current.innerHTML = result;\n\n    onAnimationFrame && onAnimationFrame(result);\n\n    /**\n     * Exit if the result is equal to the input\n     *\n     * - Trim control to text length\n     * - fire onAnimationEnd\n     */\n    if (result === text) {\n      controlRef.current.splice(text.length, controlRef.current.length);\n      onAnimationEnd && onAnimationEnd();\n\n      cancelAnimationFrame(rafRef.current);\n    }\n\n    stepRef.current++;\n  };\n\n  /**\n   * Reset scramble controls\n   *\n   * if overflow is true, overflow the control to the an empty array, the size of the text input. This will cause the animation to play from an empty string\n   */\n  const reset = () => {\n    stepRef.current = 0;\n    scrambleIndexRef.current = 0;\n    overdriveRef.current = 0;\n    if (!overflow) {\n      controlRef.current = new Array(text?.length);\n    }\n  };\n\n  /**\n   * Restarts the animation\n   *\n   * Cancels the current animation frame, resets the scramble index and other controls, and requests a new animation\n   */\n  const play = () => {\n    cancelAnimationFrame(rafRef.current);\n    reset();\n    onAnimationStart && onAnimationStart();\n    rafRef.current = requestAnimationFrame(animate);\n  };\n\n  /**\n   * reset scramble when text input is changed\n   */\n  useEffect(() => {\n    reset();\n  }, [text]);\n\n  /**\n   * start or stop animation when text and speed change\n   */\n  useEffect(() => {\n    cancelAnimationFrame(rafRef.current);\n\n    rafRef.current = requestAnimationFrame(animate);\n\n    // cancel raf on unmount\n    return () => {\n      cancelAnimationFrame(rafRef.current);\n    };\n  }, [animate]);\n\n  useEffect(() => {\n    if (!playOnMount) {\n      controlRef.current = text.split('');\n      stepRef.current = text.length;\n      scrambleIndexRef.current = text.length;\n      overdriveRef.current = text.length;\n      draw();\n      cancelAnimationFrame(rafRef.current);\n    }\n  }, []);\n\n  return { ref: nodeRef, replay: play };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}